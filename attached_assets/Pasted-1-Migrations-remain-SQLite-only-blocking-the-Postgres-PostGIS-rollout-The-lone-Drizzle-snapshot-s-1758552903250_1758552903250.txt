1. Migrations remain SQLite-only, blocking the Postgres/PostGIS rollout
The lone Drizzle snapshot still contains SQLite-specific DDL (AUTOINCREMENT, julianday defaults), so drizzle-kit push fails against PostgreSQL and prevents us from adding PostGIS columns or running the new migration set.
Suggested taskRebuild Drizzle migrations for PostgreSQL + PostGIS
Start task 1. Spin up a local Postgres instance (Docker or cloud) and export `DATABASE_URL`/`DATABASE_SSL`. 2. Archive the current SQLite artifacts under `migrations/` and `migrations/meta/`. 3. Regenerate migrations via `npx drizzle-kit generate` (include `drizzle.location.config.ts` if needed) so new SQL targets Postgres/PostGIS. 4. Apply them with `npx drizzle-kit push` to confirm clean execution, then commit the regenerated SQL and metadata. 5. Update `README.md`/`SETUP.md` with Postgres prerequisites and the new migration workflow.

2. Property schema lacks the search-focused columns and numeric types the roadmap needs
properties still stores price as text and has no fts, geom, completeness_score, or is_active fields, leaving us without the inputs for BM25/geo ranking, freshness, or quality scoring.
Suggested taskExtend property schema with FTS, geo, and quality columns
Start task 1. Modify `shared/schema.ts` to introduce `fts` (`tsvector`), `geom` (`geography(Point,4326)`), `completenessScore` (`integer`), `isActive` (`boolean`), and convert monetary fields to numeric. 2. Generate dedicated migrations that add the columns, install `pg_trgm`, and create the required GIN/GiST/partial indexes plus the FTS trigger. 3. Backfill existing rows (geom from `latitude/longitude`, completeness defaults) via a data migration or script. 4. Update seeds and storage modules to populate the new fields and guard by `isActive`. 5. Document the schema change and how to run `ANALYZE`/`EXPLAIN` checks for the new indexes.

3. Search endpoints still use ad-hoc parsing with no caching or unified ranking pipeline
search-aggregator.ts applies regex heuristics and per-request DB calls, while /api/search in server/index.ts just forwards to it without cache, entity filters, or multi-signal scoring—far from the unified, cached API described in the roadmap.
Suggested taskReplace ad-hoc search aggregator with unified, cached service
Start task 1. Introduce `server/routes/search-routes.ts` exposing `/api/search` with typed params (entity, text, facets, geo, sort). 2. Break `search-aggregator.ts` into parser, candidate retrieval (SQL with BM25/proximity/freshness), and ranker modules, leveraging the new schema fields. 3. Add `server/lib/cache.ts` (Redis + in-memory fallback) to cache query+geo hashes with 30–60 s TTL and wire invalidation hooks into property/rental/service mutations. 4. Update frontend hooks/pages to consume the new response envelope (scores, pagination, diagnostics). 5. Cover parser, scoring math, and cache keying with Vitest; add integration tests for facet/geo combinations.

4. Error monitoring and tracing are absent, leaving no observability for failures
Errors are just logged to the console in the client error boundary, and the server search handler prints to stdout—there’s no Sentry, tracing, or metrics path as mandated in the plan.
Suggested taskWire Sentry and OpenTelemetry across client and server
Start task 1. Install `@sentry/react`, `@sentry/node`, and OpenTelemetry SDK packages. 2. Initialize Sentry in `client/src/main.tsx` and `server/index.ts`, forwarding ErrorBoundary captures via `Sentry.captureException`. 3. Add a `server/observability/otel.ts` that sets up traces (Express, Postgres, Redis) and expose Prometheus metrics at `/metrics`. 4. Enrich request logging with trace/request IDs and surface them in responses for correlation. 5. Update deployment docs with DSNs, sampling strategy, and alert thresholds; ensure CI fails if env vars are missing in production builds.

5. Location UX still relies on Mapbox suggestions and hard-coded lists instead of the Botswana hierarchy
PropertyLocationStep pulls Mapbox forward geocodes and stores a freeform area_text, and search suggestions rely on a static array—neither consume the district/settlement/ward tables defined in shared/schema.ts, so the hierarchical flow and cached location APIs remain unimplemented.
Suggested taskBack listing UX and suggestions with the Botswana location graph
Start task 1. Build REST endpoints (e.g., `/api/locations/search`, `/api/locations/tree`) backed by the `districts/settlements/wards/plots` tables with queryable indices. 2. Refactor `PropertyLocationStep` into a stepped selector (district → settlement → ward → street/plot) that hydrates from those endpoints before handing off to Mapbox for precise pin drops. 3. Replace the hard-coded suggestion arrays in `/api/search/suggestions` with queries against the location tables and popular search logs, caching responses for <150 ms p95. 4. Persist the chosen hierarchy IDs alongside coordinates when creating listings and expose them in search filters. 5. Add integration tests (client + API) to verify hierarchy selection, map recentering, and suggestion performance.


Repository overview
•	Documentation & setup – The README and architecture guide detail platform capabilities, tech stack, and runtime topology, providing onboarding context for contributors.
•	Shared schema – shared/schema.ts centralizes Drizzle table definitions and Zod insert schemas for users, properties, interactions, and reviews, keeping server and client aligned on data shapes.
Backend highlights
•	Express bootstrap – server/index.ts wires security middleware, rate limiting, health checks, and mounts the modular routers for rentals, marketplace, AI search, billing, and search aggregation.
•	Auth routes – server/routes/auth-routes.ts implements registration, login, and authenticated user retrieval with password hashing and storage helpers.
Frontend highlights
•	App shell & routing – client/src/App.tsx composes global providers (React Query, auth, property context) and maps dozens of feature routes across properties, services, analytics, and dashboards.
•	Session management – client/src/contexts/AuthContext.tsx persists tokens, fetches the current user, and exposes permission helpers to gate routes.
•	Search UX – client/src/components/search/AISearchBar.tsx debounces natural-language queries, calls the AI-backed /api/search/ai, and surfaces suggestions and quick searches.
•	Homepage experience – client/src/pages/HomePage.tsx orchestrates hero slideshows, featured tiles, and CTA sections, while client/src/components/HeroCarousel.tsx fetches featured listings for the hero banner
