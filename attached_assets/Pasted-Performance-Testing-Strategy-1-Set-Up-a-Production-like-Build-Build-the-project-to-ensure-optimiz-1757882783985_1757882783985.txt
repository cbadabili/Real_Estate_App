Performance Testing Strategy
1. Set Up a Production‑like Build
Build the project to ensure optimizations are enabled (npm run build for both client/ and server/).

Run the server using the compiled code to reflect real runtime behavior.

2. Front‑End Performance
Lighthouse / WebPageTest
Evaluate page load metrics (FCP, LCP, TTI). Focus on heavy routes like MapSearchPage or dashboards that render many components.

React Profiler
Profile components such as components/layout/Navbar.tsx, map widgets, and large lists to find slow renders or unnecessary re‑renders.

Bundle Analysis
Use vite build --mode production --analysis or tools like source-map-explorer to detect large dependencies and verify code‑splitting.

Network Simulation
In browser devtools, throttle bandwidth to 3G/4G and capture how API calls and image downloads affect user-perceived speed.

3. Back‑End Performance
Load Testing
Use tools like k6, artillery, or autocannon to simulate concurrent traffic. Target endpoints that may be intensive:

GET /api/properties, GET /api/rentals/search

POST /api/users/login, POST /search/ai

Profiling
Run the server with node --prof dist/server/index.js or clinic flame to capture CPU hotspots, memory leaks, or blocking operations.

Database Inspection
Run EXPLAIN ANALYZE on SQL queries generated by storage modules (server/storage.ts, server/rental-storage.ts) to ensure indexes are used and long-running queries are optimized.

4. Continuous Monitoring
Collect metrics (CPU, memory, request latency) during load tests using Node’s process.metrics() or an APM tool.

Enable logging/metrics around external integrations (OpenAI in ai-search.ts, geocoding, etc.) to understand their latency impact.

5. Baseline & Regression Tracking
Record baseline metrics (throughput, average latency, error rates) and integrate load tests into CI/CD.

Compare subsequent runs to detect regressions whenever new features or dependencies are added.

This approach balances synthetic benchmarks (load tests and profiling) with real-user metrics (Lighthouse and React Profiler) to ensure both server and client remain performant as the application evolves.